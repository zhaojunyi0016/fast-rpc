1. ✅ 服务调用方 ->发起一个调用 :
    1. 发送报文 writeAndFlush(object)
    2. pipeline 就生效了, 报文开始出站
    3. 第一个处理器 log
    4. 第二个处理器 编码器 (将 object 转换成 报文对象) (将 报文对象 序列化成二进制) (将 二进制数据 进行 压缩)


2. ✅ 服务提供方 ->接受一个调用 :
    1. 通过 netty 接收一个报文
    2. pipeline 就生效了, 报文开始入站
    3. 第一个处理器 log
    4. 第二个处理器 解码器 (将 入站请求 解压缩)  (将 二进制数据 反序列化) (将 object 解析成 报文对象)
    5. 封装响应 -> 写回给调用方 发送报文 writeAndFlush(object)


3. ✅ 异常重试
    1. String sayHi = helLoYrpc。sayHi(“你好yrpc“)；
    2. 突然发生了网络抖动，导致响应超时，或者压根没有响应重试？
    3. 增删改的请求， 因为网络抖动，发动了多个请求，会不会改变原有的业务逻辑（幂等性） 查询天然具有幂等性

4. ✅ 如何保护自己
    1. 服务提供方 : 如果有大量流量进来, 顶不住 ----> 限流
    2. 服务调用方 : 发送了大量请求都不行, 就没必要继续调用了 -----> 熔断/降级


5. ✅ 熔断/限流 导致心跳无法正常处理, 导致动态下线服务
    1. 熔断和限流, 不限制心跳检测


6. ✅ 优雅启停
    1. 通过 Runtime.getRuntime().addShutdownHook() 关机钩子函数, 处理对应请求